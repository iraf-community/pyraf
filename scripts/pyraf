#! /usr/bin/env python3
import sys
import os
import shutil
import argparse

from stsci.tools import capable


if "." not in sys.path:
    sys.path.insert(0, ".")

from pyraf import __version__


# command-line options
desc = '''
PyRAF is a command language for running IRAF tasks in a Python like
environment.
'''
epilog = '''
Copyright (C) 2003 Association of Universities for Research in
Astronomy (AURA).
'''
parser = argparse.ArgumentParser(prog='pyraf', description=desc,
                                 epilog=epilog)
parser.add_argument('-c', '--command',
                    help='Command passed in as string'
                         ' (any valid PyRAF command)',
                    metavar='cmd')
parser.add_argument('-e', '--ecl',
                    help='Turn on ECL mode',
                    action='store_true', default=False)
parser.add_argument('-i',
                    help='No command line wrapper, just run standard'
                         ' interactive Python shell',
                    action='store_false', dest='commandwrapper')
parser.add_argument('-m',
                    help='Run command line wrapper to provide extra'
                         ' capabilities (default)',
                    action='store_true', dest='commandwrapper')
parser.add_argument('--commandwrapper',
                    help='Use of command line wrapper',
                    metavar='y|n', type=bool, default=True)
parser.add_argument('-n', '--nosplash',
                    help='No splash screen during startup (also see -x)',
                    action='store_true', default=not capable.OF_GRAPHICS)
parser.add_argument('-s', '--silent',
                    help='Silent initialization (does not print'
                         ' startup messages)',
                    action='store_true', default=False)
parser.add_argument('-V', '--version',
                    help='Print version info and exit',
                    action='version', version=__version__)
parser.add_argument('-v', '--verbose',
                    help='Set verbosity level (may be repeated'
                         ' to increase verbosity)',
                    action='count', default=0)
parser.add_argument('-x', '--nographics',
                    help='No graphics will be attempted/loaded'
                         ' during session',
                    action='store_true', default=False)
parser.add_argument('-y', '--ipython',
                    help='Run the IPython shell instead of the normal'
                         ' PyRAF command shell',
                    action='store_true', default=False)
parser.add_argument('savefile',
                    help='Optional savefile to start from',
                    nargs='?')

# allow the use of PYRAF_ARGS
extraArgs = os.environ.get('PYRAF_ARGS', '').split()

# Special case that the executable is called epyraf --> ECL mode
if sys.argv[0] == 'epyraf':
    extraArgs.append('-e')

args = parser.parse_args(sys.argv[1:] + extraArgs)

# Show version at earliest possible moment when in debugging/verbose mode.
if args.verbose > 0:
    print('pyraf version ' + __version__)

# handle any warning supression right away, before any more imports
if args.silent:
    import warnings
    warnings.simplefilter("ignore")

# allow them to specifiy no graphics, done before any imports
if args.nographics:
    os.environ['PYRAF_NO_DISPLAY'] = '1'  # what the rest of PyRAF triggers on

from pyraf import pyrafglobals
pyrafglobals._use_ecl = args.ecl

from pyraf import iraf
iraf.setVerbose(args.verbose)

# If not silent and graphics is available, use splash window
if args.silent:
    splash_screen = None
    initkw = {'doprint': False, 'hush': True}
else:
    initkw = {}
    if not args.nosplash:
        from pyraf import splash
        splash_screen = splash.splash('PyRAF ' + __version__)
    else:
        splash_screen = None

if args.verbose > 0:
    print("pyraf: splashed")

# read the user's startup file (if there is one)
if 'PYTHONSTARTUP' in os.environ and \
        os.path.isfile(os.environ["PYTHONSTARTUP"]):
    exec(
        compile(
            open(os.environ["PYTHONSTARTUP"]).read(),
            os.environ["PYTHONSTARTUP"], 'exec'))

# load initial iraf symbols and packages

# If iraf.Init() throws an exception, we cannot be confident
# that it has initialized properly.  This can later lead to
# exceptions from an atexit function.  This results in a lot
# of help tickets about "gki", which are really caused by
# something wrong in login.cl
#
# By setting iraf=None in the case of an exception, the cleanup
# function skips the parts that don't work.  By re-raising the
# exception, we ensure that the user sees what really happened.
#
# This is the case for pyraf invoked from the command line.
try:
    if args.savefile:
        iraf.Init(savefile=args.savefile, **initkw)
    else:
        iraf.Init(**initkw)
except Exception:
    iraf = None
    raise
if args.verbose > 0:
    print("pyraf: finished iraf.Init")

if splash_screen is not None:
    splash_screen.Destroy()

# By now, the bulk of the startup work is done
logout = quit = exit = 'Use ".exit" to exit'

# IPython Pyraf profile RC installation - this is only done so
# that the next step (below) can find/run the rc file (to execute
# some pyraf magic setup)
if args.ipython:
    # the following should be removed soon, it is only used for versions
    # of IPython older than 0.11
    import pyraf
    home = None
    ip = os.getenv("IPYTHONDIR")
    if not ip:
        home = os.getenv("HOME") or ""
        ip = os.path.join(home, ".ipython")

    pyrafrc_dest = os.path.join(ip, "ipythonrc-pyraf")
    pyrafrc_source = os.path.join(
        os.path.split(pyraf.__file__)[0], "ipythonrc-pyraf")
    if os.path.exists(ip):
        if not os.path.exists(pyrafrc_dest):
            shutil.copy(pyrafrc_source, pyrafrc_dest)
    else:
        os.mkdir(ip)
        shutil.copy(pyrafrc_source, pyrafrc_dest)
else:
    if not args.silent:
        print("PyRAF {} Copyright (c) 2002 AURA".format(__version__))
        # just print first line of Python copyright (long in v2.0)
        print("Python {} {}".format(sys.version.split()[0],
                                    sys.copyright.split('\n')[0]))

# Run given command
if args.command:
    iraf.task(cmd_line=args.command, IsCmdString=True)
    iraf.cmd_line()
    sys.exit()

# Start command line
if args.commandwrapper:
    # Start up command line wrapper keeping definitions in main name space
    # Keep the command-line object in namespace too for access to history
    if args.ipython:
        # rewrite sys.argv
        new_argv = [
            "ipython",
        ]
        if args.silent:
            new_argv.append("--no-banner")
        sys.argv = new_argv[:]

        # Start the interactive shell.  Also, see IPython.embed() here:
        #     http://ipython.org/ipython-doc/stable/interactive/ \
        #     reference.html#embedding-ipython
        from IPython.terminal.ipapp import TerminalIPythonApp
        app = TerminalIPythonApp.instance()
        app.initialize()
        # import pyraf to write this shell obj to its namespace
        # we have already fully imported it above
        import pyraf
        # create and run the Ipython shell - it takes over from here
        pyraf._ipyshell = app.shell
        # in the end, with this run_code(), all of this is the equivalent
        # of simply running ipython standalone with these imports
        pyraf._ipyshell.run_code(
            'from pyraf import iraf, ipython_api; from stsci.tools.irafglobals import INDEF, Verbose, yes, no'
        )
        app.start()
        sys.exit()
    else:
        import pyraf.pycmdline
        pycmdline = pyraf.pycmdline.PyCmdLine(locals=globals())
        if args.silent:
            pycmdline.start('')  # use no banner
        else:
            pycmdline.start()  # use default banner
else:
    # run the standard Python interpreter
    import code
    code.interact(local=locals())
